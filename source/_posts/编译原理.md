---
title: 编译原理
tags:
  - 编译原理
categories:
  - 笔记
mathjax: true
toc: true
date: 2025-01-02 14:14:22
password:
id: Principles-and-Practice-of-Compiler-Construction
---

这是清华大学计算机系 2024 年秋季课程《编译原理》的期末复习笔记。

<!-- more -->

## 第一讲：课程概述

### T 型图



## 第二讲：词法分析

我认为很有意思的是以下题目：

> 已知 Java 中的“注释”以 `/*` 开始，以 `*/` 结束，在 `/*` 和 `*/` 之间，除了 `*/` 序列外，可以出现任意字符。请构造一个正则表达式来匹配所有此类注释。

直接设计正则表达式是困难的；所以我先构造了一个 DFA，再转为正则表达式。

```mermaid
graph LR

style Start fill:none,stroke-width:0px

Start --> A(( ))
A --> |others| A
A --> |/*| B(( ))
B --> |$\Sigma$ - *| B
B --> |*| C(( ))
C --> |*| C
C --> |$\Sigma$ - * - /| B
C --> |/| D((( )))
```

可以写出正则表达式为：
$$
/*\left(\left(\Sigma - \{*\}\right) + **^*\left(\Sigma - \{*, /\}\right)\right)^* **^*/
$$

## 第三讲：自顶向下语法分析

带回溯的自顶向下语法分析过程中存在两类非确定性：

1. 选择对哪一个非终结符进行展开；
2. 如果选定的非终结符是多个产生式的左部，那么应该选择使用哪一个产生式。

对于第一类非确定性而言，我们可以考虑**只允许最左推导或最右推导**来避免；对于第二类非确定性而言，我们可以考虑使用**自顶向下预测分析**：向前查看确定树木的单词符号，然后确定应该选择哪一个产生式进行最左推导。

### LL(1) 分析

LL(1) 是指，**L**eft-to-right, **L**eftmost derivation with **1** token of lookahead。

对于 CFG $G = \{V_N, V_T, P, S\}$ 而言，我们一般想要研究
$$
X_G = V_N \cup V_T \cup \{\varepsilon\} \cup \{v \mid A \to u, v \text{ is a suffix of } u\}.
$$

#### First 集合

对于 CFG $G = \{V_N, V_T, P, S\}$ 而言，$\alpha \in (V_N \cup V_T)^*$ 的 First 集合的定义为
$$
\text{First}(\alpha) = \{a \mid \alpha \overset{*}{\implies}a\beta, a \in V_T, \beta \in (V_N \cup V_T)^*, \text{or } a = \varepsilon \text{ when } \alpha \overset{*}{\implies} \varepsilon\}.
$$
直观上讲，一个句型 $\alpha$ 若能够推导出另一个以终结符 $a$ 开头的句型，则 $a \in \text{First}(\alpha)$；若 $\alpha$ 可以推导出 $\varepsilon$，则 $\varepsilon \in \text{First}(\alpha)$。

**步骤**

- 初始化：对于所有 $x \in V_T\cup\{\varepsilon\}$，都有 $\text{First}(x) = \{x\}$；对于其他 $x$，都有 $\text{First}(x) = \varnothing$。
- 迭代：重复以下步骤，直至所有 First 集合均不变。
  - 对于 $y_1y_2\cdots y_k \in \{v \mid A \to u \in P, v \text{ is a suffix of } u\}$ 而言，
    - 若能找到 $i \in [1, k]$ 使得 $\varepsilon \in \text{First}(y_j), \forall j \in [1, i - 1]$ 且 $\varepsilon \notin \text{First}(y_i)$，则
      $$
      \text{First}(y_1y_2\cdots y_k) = \left(\bigcup_{1 \le j \le i}\text{First}(y_j)\right) - \{\varepsilon\}.
      $$
    - 否则
      $$
      \text{First}(y_1y_2\cdots y_k) = \bigcup_{1 \le j \le k}\text{First}(y_j).
      $$
  - 对所有 $A \to y_1y_2\cdots y_k \in P$，置
    $$
    \text{First}(A) \gets \text{First}(A) \cup \text{First}(y_1y_2\cdots y_k).
    $$

关键在于找到第一个满足 $\varepsilon \notin \text{First}(y_i)$ 的 $i$。它不能推导出 $\varepsilon$，说明从 $y_1y_2 \cdots y_k$ 推导出的句型的首字母：

- 前面的 $y_j$，不全推导为 $\varepsilon$，得到 $\bigcup_{1 \le j \le i - 1}\text{First}(y_j)$。
- 前面的 $y_j$ 全推导为 $\varepsilon$，得到 $\text{First}(y_i)$。

在 $y_i$ 的时候截断了——对于 $y_j, \forall j \ge i + 1$ 而言，它不会再对 $y_1y_2 \cdots y_k$ 的 First 集合产生贡献。

#### Follow 集合

对于 CFG $G = \{V_N, V_T, P, S\}$ 而言，$A \in V_N$ 的 Follow 集合的定义为
$$
\text{Follow}(A) = \{a \mid S\# \overset{*}{\implies} \alpha A \beta\#, a \in \text{First}(\beta\#), \alpha, \beta \in (V_N \cup V_T)^*\}.
$$

直观上讲，若 $G$ 中存在一个包含子串 $Aa$ 的句型，则 $a \in \text{Follow}(A)$；若 $G$ 中存在一个以 $A$ 结尾的句型，则 $\# \in \text{Follow}(A)$。

显然，一定有 $\# \in \text{Follow}(S)$。

**步骤**

- 初始化：$\text{Follow}(S) = \{\#\}$；对于其他的 $A \in V_N$，都有 $\text{Follow}(A) = \varnothing$。
- 迭代：重复以下步骤，直至所有 Follow 集合均不变。
  若有 $A \to \alpha B \beta \in P, \alpha, \beta \in (V_N \cup V_T)^*, B \in V_N$，则
  - $\text{Follow}(B) \gets \text{Follow}(B) \cup \left(\text{First}(\beta) - \{\varepsilon\}\right)$。
  - 若 $\varepsilon \in \text{First}(\beta)$，则 $\text{Follow}(B) \gets \text{Follow}(B) \cup \text{Follow}(A)$。

也就是说，对于所有产生式的右部的非终结符 $B$ 而言，设 $B$ 后面接着的是 $\beta$，那么 $\text{Follow}(B)$ 肯定要包含 $\text{First}(\beta) - \{\varepsilon\}$。另外，如果 $\varepsilon \in \text{First}(\beta)$，这说明 $A$ 可以推导出以 $B$ 为后缀的句型（此时让 $\beta \overset{*}{\implies}\varepsilon$）。那么，$A$ 后面能立即跟着的终结符，也能跟在 $B$ 的后面，所以 $\text{Follow}(B)$ 还需要包含 $\text{Follow}(A)$。

#### 预测集合 PS

对于 CFG $G = \{V_N, V_T, P, S\}$ 而言，$A \to \alpha \in P$ 的预测集合的定义为：

- 若 $\varepsilon \notin \text{First}(\alpha)$，则 $\text{PS}(A \to \alpha) = \text{First}(\alpha)$；
- 若 $\varepsilon \in \text{First}(\alpha)$，则 $\text{PS}(A \to \alpha) = (\text{First}(\alpha) - \{\varepsilon\}) \cup \text{Follow}(A)$。

直观上来讲，$\text{PS}(A \to \alpha)$ 中的元素表示的是 LL(1) 分析过程中 $A$ 能和哪些终结符匹配：要么是匹配不含 $\varepsilon$ 的 $\text{First}(\alpha)$，要么是 $\alpha \overset{*}{\implies}\varepsilon$ 后匹配 $\text{Follow}(A)$。

$G$ 是 LL(1) 的，当且仅当对于 $G$ 中任意两个有相同左部的产生式 $A \to \alpha$ 和 $A \to \beta$，都满足 $\text{PS}(A \to \alpha) \cap \text{PS}(A \to \beta) = \varnothing$。

#### 预测分析表

如果 $A \to \alpha \in P$，则在 $S$ 行 $\text{PS}(A \to \alpha)$ 列的单元中写下 $\alpha$。

| 非终结符\终结符 |     $a$     |         $b$         |     $c$     |    $d$    | $\#$ |
| :-------------: | :---------: | :-----------------: | :---------: | :-------: | :--: |
|       $S$       | $S \to AaS$ |     $S \to BbS$     | $S \to BbS$ | $S \to d$ |      |
|       $A$       |  $A \to a$  |                     |             |           |      |
|       $B$       |             | $B \to \varepsilon$ |  $B \to c$  |           |      |

**表驱动 LL(1) 分析程序**

- 初始时栈中仅含 $\#$。然后将文法初始符号 $S$ 入栈。
- 迭代：重复以下步骤，直至栈顶为 $\#$ 且串当前字符也为 $\#$。
  - 若栈顶为非终结符，则弹出该终结符，依据串当前字符，在预测分析表中找到相应的产生式，**从上到下**将产生式右部放置于栈中。
  - 若栈顶为终结符，则检查是否与串当前字符匹配。

#### 消除左递归

**消除直接左递归**

对于文法
$$
P \to P\alpha_1 \mid P\alpha_2 \mid \cdots \mid P\alpha_m \mid \beta_1 \mid \beta_2 \mid \cdots \mid \beta_n
$$
而言，可以消除直接左递归，将产生式改写为：
$$
\begin{align*}
P &\to \beta_1Q \mid \beta_2Q \mid \cdots \mid \beta_n Q \\
Q & \to \alpha_1Q \mid \alpha_2Q \mid \cdots \mid \alpha_mQ \mid \varepsilon
\end{align*}
$$

一定不要忘记最后的 $\varepsilon$。

**消除间接左递归**

假设所有的非终结符有排序：$A_1, A_2, \cdots, A_k$，按照以下步骤消除所有的间接左递归：

- 对于每个 $A_i$，考虑位于它前面的 $A_j(1 \le j < i)$。用 $A_i \to \alpha_1r \mid \alpha_2r \mid \cdots \mid \alpha_tr$ 来反复替代 $A_i \to A_j r$ 的产生式，其中 $A_j \to \alpha_1 \mid \alpha_2 \mid \cdots \mid \alpha_t$。
- 消除关于 $A_i$ 的直接左递归。

> 例：设文法 $G[S]$ 为
> $$
> \begin{align*}
> S &\to PQ \mid a \\
> P &\to QS \mid b \\
> Q &\to SP \mid c
> \end{align*}
> $$
> 试变换该文法，得到一个等价的不含左递归的文法。假设非终结符排序为 $S, P, Q$。

顺序为：$P$ 被 $S$ 替换，$Q$ 被 $S$ 替换，$Q$ 被 $P$ 替换。

第一轮对 $S$ 进行操作后（实际上未发生变化）为：
$$
\begin{align*}
S &\to PQ \mid a \\
P &\to QS \mid b \\
Q &\to SP \mid c
\end{align*}
$$

第二轮对 $P$ 进行操作后（实际上未发生变化）为：
$$
\begin{align*}
S &\to PQ \mid a \\
P &\to QS \mid b \\
Q &\to SP \mid c
\end{align*}
$$

第三轮对 $Q$ 进行操作后（先替换 $S$，再替换 $P$）为：

- 先替换 $S$
  $$
  \begin{align*}
  S &\to PQ \mid a \\
  P &\to QS \mid b \\
  Q &\to PQP \mid aP \mid c
  \end{align*}
  $$
- 再替换 $P$
  $$
  \begin{align*}
  S &\to PQ \mid a \\
  P &\to QS \mid b \\
  Q &\to QSQP \mid bQP \mid aP \mid c
  \end{align*}
  $$
- 再消除直接左递归
  $$
  \begin{align*}
  S &\to PQ \mid a \\
  P &\to QS \mid b \\
  Q &\to bQPR \mid aPR \mid cR \\
  R &\to SQPR \mid \varepsilon
  \end{align*}
  $$

#### 提取左公因子

对于文法
$$
P \to \alpha\beta_1 \mid \alpha\beta_2 \mid \cdots \mid \alpha\beta_m \mid \gamma_1 \mid \gamma_2 \mid \cdots \mid \gamma_n
$$
而言，可以提取左公因子，将产生式改写为：
$$
\begin{align*}
P & \to \alpha Q \mid \gamma_1 \mid \gamma_2 \mid \cdots \mid \gamma_n \\
Q & \to \beta_1 \mid \beta_2 \mid \cdots \mid \beta_m
\end{align*}
$$

## 第四讲：符号表

### 开作用域和闭作用域

- 该点作用域为**当前作用域**，
- 当前作用域与包含它的程序单元所构成的作用域称为**开作用域**，
- 不属于开作用域的作用域称为**闭作用域**。

### 单符号表与多符号表

```pascal
const a = 25;
var x, y; // (1)
procedure p;
    var z;
    begin
        ...
    end;
procedure r;
    var x, s; // (2)
    procedure t;
        var v, x, y; // (3)
        begin
        	...
       	end;
    begin
    	... // here
   	end;
begin
	...
end;
```

对于单符号表而言，所有的嵌套的定义域共用一个全局符号表。此时符号表中有 `a`、(2) 处的 `x`、(1) 处的 `y`、`p`、`r`、`x`、`s`、`t`。

对于多符号表而言，每个作用域都有各自的符号表，用一个栈来维护。此时符号表的组织为：

| 栈中位置     | 作用域              | 符号集合                | 开/闭    |
| ------------ | ------------------- | ----------------------- | -------- |
| 栈底         | 全局作用域          | `a`、`x`、`y`、`p`、`r` | 开作用域 |
| 栈顶         | 过程 `r` 的作用域   | `x`、`s`、`t`           | 开作用域 

不在符号表中的作用域有：

| 栈中位置     | 作用域              | 符号集合                | 开/闭    |
| ------------ | ------------------- | ----------------------- | -------- |
| （不在栈中） | 过程 `p` 的作用域   | `z`                     | 闭作用域 |
| （不在栈中） | 过程 `t` 的作用域 3 | `v`、`x`、`y`           | 闭作用域 |

## 第五讲：自底向上语法分析

### 短语、直接短语、句柄

直观上来讲，

- **短语**是指分析树中非叶节点对应的果实；
- **直接短语**是指高度（注意：高度是指到子树中最远叶节点的距离，而非深度）为 $1$ 的节点对应的果实；
- **句柄**是指分析树中最左侧的直接短语。

> 例：已知文法 $G[S]$：
> $$
> \begin{align*}
> S & \to AB \\
> A & \to aA \mid \varepsilon \\
> B & \to b \mid bB
> \end{align*}
> $$
> 试指出句型 $aaAb$ 的全部短语、直接短语、句柄。

画出 $aaAb$ 的分析树如下：

```mermaid
graph TD

S[S] --- A1[A]
S --- B[B]
A1 --- a1[a]
A1 --- A2[A]
B --- b[b]
A2 --- a2[a]
A2 --- A3[A]

classDef yellow fill:#FF0;
class A2,B yellow
```

每个非叶节点对应果实对应一个短语，所以所有的短语如下：
$$
aaA, aA, b, aaAb
$$
高度为 $1$ 的为非叶节点（图中高亮的节点）对应直接短语：
$$
aA, b
$$
最左侧的直接短语为句柄：
$$
aA
$$
如果分析树不唯一，则短语、直接短语和句柄是**所有分析树对应结果的并集**。

### 移进-归约分析

移进-归约分析借助一个栈（称为下推栈或分析栈）来实现，拥有两种动作：移进（Shift）和归约（Reduce）。**移进**是指从输入序列中将一个单词符号移入分析栈，**归约**是指按照确定的方式对位于分析栈栈顶的短语进行归约。

#### 移进-归约分析中的冲突

- **移进-归约冲突**：不能确定下一步应该移进，还是应该归约。
- **归约-归约冲突**：不能确定下一步应该对栈顶的哪一个短语进行归约。

### LR 分析方法

LR 是指，**L**eft-to-right, **R**ightmost derivation。在 LR 分析中，归约是对栈顶**句柄**进行归约。在设计 LR 分析程序时，通常是做法是在分析栈中存放分析引擎的当前状态，这样的分析栈，我们称之为**状态栈**。

#### ACTION 表和 GOTO 表

- $\text{ACTION}[k, a] = \text{s}i$，**Shift**：将状态 $i$ 移进栈顶，且输入串指针指向下一输入符号。
- $\text{ACTION}[k, a] = \text{r}j$，**Reduce**：按第 $j$ 条产生式归约。
- $\text{GOTO}[i, A] = j$：若按照 $A \to \alpha$ 进行归约，则需要将栈顶的 $|\alpha|$ 个状态弹出，此时栈顶状态为 $i$，**不将其弹出**，再将状态 $j$ 移进栈顶。

如果同时含有状态栈和符号栈，则需要

- $\text{ACTION}[k, a] = \text{s}i$，**Shift**：将输入符号也移进符号栈栈顶。
- $\text{ACTION}[k, a] = \text{r}j$，**Reduce**：按第 $j$ 条产生式修改符号栈栈顶的符号。
- $\text{GOTO}[i, A] = j$：此时将符号 $A$ 伴随着状态 $j$ 移进栈顶。

### LR(0) 分析

LL(1) 是指，**L**eft-to-right, **L**eftmost derivation with **0** token of lookahead。

#### 增广文法

对于 $G[S]$ 而言，构造 $G[S']$，添加 $S'\to S$ 使得开始符号不会出现在任何产生式的右部。可以证明，$G[S'] = G[S]$。

#### 活前缀

对于 CFG $G = \{V_N, V_T, P, S\}$ 而言，若 $S \overset{*}{\underset{\text{rm}}{\implies}} \alpha A w$ 且 $A \implies \beta$，其中 $\alpha, \beta \in (V_N \cup V_T)^*, w \in V_T^*$，即 $\beta$ 是右句型 $\alpha\beta w$ 的一个相对于非终结符 $A$ 的句柄，则 $\alpha\beta$ 的任何前缀 $\gamma$ 都是文法 $G$ 的**活前缀**。

直观上来说，$\gamma \in (V_N \cup V_T)^*$ 是活前缀，当且仅当存在 $w \in L(G)$，使得 $\gamma$ 恰好是针对 $w$ 的分析过程中，**某个时刻分析栈上的符号串**（$\#$ 除外）。**活前缀是某个右句型的前缀，且这个前缀的右侧不超过该句型的某个句柄。**它们的关系如下：

- 活前缀已经含有该句柄的全部符号：表明该句柄对应的产生式 $A \to \alpha$ 的右部 $\alpha$ 已经出现在栈顶。
- 活前缀只含该句柄的一部分符号：表明该句柄对应的产生式 $A \to \alpha_1\alpha_2$ 的右部的子串 $\alpha_1$ 已经出现在栈顶，期待从输入串中看到可以由 $\alpha_2$ 推导出的字符串。
- 活前缀不含有该句柄的任何符号：此时期待从输入串中看到该句柄对应的产生式 $A \to \alpha$ 的右部所推导出的符号串。

#### LR(0) 有限状态机

**项目**

项目（item）是指由产生式 $A \to xyz$ 得到的形如 $A \to x.yz$ 的式子，圆点标志着已分析过的串与该产生式匹配的位置。若 $A \to \varepsilon$，则唯一的 LR(0) 项目记作 $A \to .$。

根据圆点所在的位置和圆点后是终结符、非终结符或为空，把项目分为以下几种：

- 移进项目：形如 $A \to \alpha.a\beta$，其中 $a \in V_T, \alpha, \beta \in (V_N \cup V_T)^*$。
- 待约项目：形如 $A \to \alpha.B\beta$。
- 归约项目：形如 $A \to \alpha.$。
- 接受项目：形如 $S' \to S$。

**闭包**

LR(0) 有限状态机的每个状态是某个 LR(0) 项目集合 $I$ 的闭包 $\text{CLOSURE}(I)$。构造闭包的算法如下：

1. 设 $J \gets I$。
2. 迭代：重复以下步骤，直至 $J$ 不再变化：
   对于 $J$ 中的每个项目 $A \to \alpha.B\beta$ 和 $G$ 中的每个产生式 $B \to \gamma$，进行 $J \gets J \cup\{B \to .\gamma\}$。
3. $\text{CLOSURE}(I) = J$。

也就是对于 $I$ 中的每个项目而言，把圆点右侧的非终结符对应的所有产生式（将右部放在圆点右侧）都加进 $\text{CLOSURE}(I)$。

**初态**

初态为 $\text{CLOSURE}(\{S' \to S\})$。

**转移函数**

转移函数为
$$
\text{GO}(I, X) = \text{CLOSURE}(J),
$$
其中 $I$ 为某个由 LR(0) 有限状态机的状态，$X \in V_N \cup V_T$，$J = \{A \to \alpha X.\beta \mid A \to \alpha.X\beta \in I\}$。也就是说，$J$ 中的产生式，是  $I$ 中的产生式圆点向右移动一个文法符号 $X$ 得到的。而这条转移边的边权，即为 $X$。

**所有状态的集合**

求出 LR(0) 有限状态机的所有状态的集合 $C$ 的算法如下：

- 初始化 $C \gets \text{CLOSURE}(\{S' \to S\})$。
- 迭代：重复以下步骤，直至 $C$ 不再变化：
  对于 $C$ 中的每个项目集合 $I$ 和 $G$ 的文法符号 $X$，进行 $C \gets C \cup \text{GO}(I, X)$。
